%%%%% Server
allow toggleable server-mode (vim-like)

IDEA
  share choosen info between instances
  REF pipe/fifo/socket (like qutebrowser, tmux or nvim --headless)
    NOTE: using sockets allows us to use *core* on client and *ui* on host
    https://docs.python.org/3.5/library/socket.html
      !!! [_] READ https://docs.python.org/3/howto/sockets.html
    https://docs.python.org/3.5/library/socketserver.html
      http://stackoverflow.com/questions/20745352/creating-a-multithreaded-server-using-socketserver-framework-in-python
    https://docs.python.org/3.5/library/asyncore.html
    http://stackoverflow.com/questions/23828264/how-to-make-a-simple-multithreaded-socket-server-in-python-that-remembers-client
      https://andreymal.org/socket3/
    Shutdown gracefully -- reuse dead connection
      http://stackoverflow.com/questions/22171441/shutting-down-python-tcpserver-by-custom-handler
      = XXX server shutdown is too slow
  multithread pool
    = NEED limited pool of threads to manage fs operations
    http://asvetlov.blogspot.ru/2010/11/1.html
    https://bytes.com/topic/python/answers/44416-how-kill-socketserver
  cooperative concurrency in single thread (Python3.5 async/await)
    https://habrahabr.ru/post/266743/
    http://stackabuse.com/python-async-await-tutorial/
    http://www.snarky.ca/how-the-heck-does-async-await-work-in-python-3-5
  asyncio
    https://docs.python.org/3/library/asyncio-task.html
    https://docs.python.org/3.5/library/asyncio.html
  shared memory
    http://stackoverflow.com/questions/33535386/better-way-to-share-memory-for-multiprocessing-in-python
    http://stackoverflow.com/questions/14124588/python-multiprocessing-shared-memory
    https://habrahabr.ru/post/167503/
    https://jeffknupp.com/blog/2013/06/30/pythons-hardest-problem-revisited/
    http://semanchuk.com/philip/posix_ipc/
  socket-only server
    http://danielhnyk.cz/simple-server-client-aplication-python-3/
  send signal from server (G: push message / z-push)
    http://stackoverflow.com/questions/2876024/linux-is-there-a-read-or-recv-from-socket-with-timeout?rq=1
    http://stackoverflow.com/questions/3745592/python-persistent-socket-connection
    - long polling :: BAD:(deprecated by websockets) too many problems if connection lost
      = hard to process all connection errors on client side
      ++ http://moduscreate.com/fast-polling-vs-websockets-2/
      http://resthooks.org/docs/alternatives/
    - fast polling :: BAD: queries in cycle, has response latency
    - server-sent-events
      https://www.html5rocks.com/en/tutorials/eventsource/basics/
  discovering running client/server nodes
    http://stackoverflow.com/questions/10914750/connect-two-tcp-sockets-without-defining-client-server-role
  +++ socket simultaneous read/write
    http://stackoverflow.com/questions/11697855/python-multithreading-run-two-functions-at-the-same-time
    http://stackoverflow.com/questions/28879706/multiple-clients-cannot-listen-and-write-at-the-same-time
  How can we verify that the server can still send messages through a socket to reach the client, without actually sending anything through that socket?
    :: You can't, unless you've enabled TCP keepalives.
    https://delog.wordpress.com/2013/08/16/handling-tcp-keepalive/
    http://www.digi.com/wiki/developer/index.php/Handling_Socket_Error_and_Keepalive
    http://note.artchiu.org/2014/07/10/how-to-change-tcp-keepalive-timer-using-python-script/
  C -- event loop
    http://software.schmorp.de/pkg/libev.html
      http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod
      http://www.win.tue.nl/~aeb/linux/lk/lk-12.html
  Protocol Design Notes
    http://www.linuxtopia.org/online_books/programming_books/python_programming/python_ch36s06.html?


State Synchronization Protocol (SSP)
  [_] TODO: look at 'mosh' internals
    https://github.com/mobile-shell/mosh
    ~ 6k lines in {crypto,network,protobufs,util}
  READ: Technical details on SSP protocol
    https://mosh.org/#techinfo
    = UDP datagrams are encrypted and authenticated using AES-128 in OCB mode.
    = synchronizing the state of any object from one host to another
  [_] TRY: implement SSP for frames sync from *dom*
  SEE:IDEA
    https://en.wikipedia.org/wiki/WASTE


THINK
  ! allow enable socket server / choose *relay* after startup by options
    E.G. enable control for *gui* colorscheme to control from outside
    => each *mod* must have 'dispatcher' for commands :: functions
  *core* must notify *ui* when /dir/* changed to reload view
    ? is it possible in current socket model, when server only inside *core* ?
    ? use 'dbus' ?
  Thin relay: 'preview image' --> *ui*
    ++ SEE: IPC : shared memory
      = render image directly into memory, displayed by *ui* for preview
      = like render into opengl second buffer
    + we need to deliver info onto screen anyway
      => be it relaying through *core* or directly
      * image/data must be aquired/generated
      * results must be outputted
        - container (memory, file, pipe, etc)
          = must be interpreted before displaying
          SEE:(mail://dev@suckless.org) universal format for image displaying, as 'feh' ALT
        - or directly to screen
          = has appeal only when greatly optimized
    ? how to do it fast ?
      < high cpu load on image transmition through socket
      ! NEED direct access
        direct memory access
        GPU memory
        X apps embedding (like already existing viewer)
          then *miur* controls only 'bonding/setup' of apps
    THINK: *core*/*ui* on different machines
      ? heuristic what is faster
        ~ generate preview on target and send image to host
        ~ send file itself (or its parts) to host and generate preview there

  Distributed model
    ? How to provide cross-communication ?
    *core* -- target
    *ui* -- host
    *preview* -- positioned completely on 3rd-party server
      like 3d rendering
      conveys only resulting images / analytics
    Distributed protocols
      * sync *proj* between *ui*
      * exchange data between *core*'s
      bittorrent

  Serialization
    E.G.
      JSON
      pickle
    compress tree structures
    snapshot diff

  Transparency (no socket)
    (option) tight-coupling of modules written in single language
      eliminate socket/serialization stuff in-between of them
    Essential for fast startup/shutdown
      server shutdown itself is 'SLOW' ~0.5s

  Client passive listening
    = NEED to wait on 'state update' signal from server
    http://users.pja.edu.pl/~jms/qnx/help/tcpip_4.25_en/prog_guide/sock_advanced_tut.html

connect to same background ranger instance on demand
  on demand make standalone as server
  distributed model -- any instance can be server
  many different *gui* can connect to single '*core*'

launch new instance from inside current manager
  > keep it independent
  > connect it to server automatically to share info

MAYBE when spawning shell -- don't use it as child
  - keep *core* working as server
  - close interface completely
  - run commands directly in the underlying shell
  - launch and connect interface again

keep background interactive shell (eliminate its startup time)
  = seems like I need nvim-like virtual terminal to virtualize IA with term escape codes
  * add '-s' server flag to :shell and make it DFL
  * replace entering into shell by switching to already launched one (with scrollback?)
