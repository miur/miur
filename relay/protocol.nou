%%%%% Protocol
Re-invent UDP-like over any other protocol/media.
Additional level of indirection.

TODO
  !!! [_] FIND distributed/remote/secure evaluation
    SEE system clocks and timestamps
    [_] http://books.ifmo.ru/book/1403/vvedenie_v_raspredelennye_vychisleniya.htm
      https://habrahabr.ru/post/232361/

%% Msg
  Format
    ask ( type, id/timestamp, dst, body )
    rsp ( type, id/timestamp, dst, body )

    type: may be single letter with fixed length body afterwards
      'rsp' can be capital letter to distinguish direction
      = NEED for unpacking objects (pickle-like)

    id-timestamp:
      id = timestamp: WARN: may become non-unique due to sys clock discrepancies
        BAD: by hacking timestamp you can alter cmds order and interleave with cmds from another client
      id = cmd: BAD performance for large cmd/selection -- no sense to send them back to client
      id = hash('cmd'): WARN: isn't enough for multiple identical cmds or same cmd from diff clients
      id = hash(('cmd', 'time', 'client')): too complex ?

    body: cmd/rsp
      maybe gzip

  Ignore msg/rsp relative order
    cmd can activate slow bkgr task, which results will be delivered long after multiple msg transactions
    NEED identify which req asked for this rsp (use id/timestamp)

  msg has addressee
    Using addressee guarantees fastest delivery
      All transit msgs must be sent immediately
        don't store into queue == reduce delivering latency for re-emitting from queue
    DFL:
      _parent_ responsible for processing -- on *mod*'s own tree branch
      _returnee_ where to send msg after processing
    target
      -t core
      -t view
      -t self
    broadcast
      -t all
      -t neighbors
      -t ui/all
      -t all/ui


%% Impl
  each msg has class
    = msg based RPC
    = execute serialized 'future' over sockets
    + best horizontal scaling for conform classes
    ? OR better to register callbacks on rsp instead of dispensable class ?
      ! need to keep request data/cmd to hang around
        check server correctness/compatibility (verify possible garbage / attack)
      ! state streaming -- send single *frame* by fragments/segments
        E.G. stream long directory
        need isolated state to track transmission progress -- so need obj

  only msg itself knows how to parse rsp from *core*
    ! keep msg obj around, until rsp will be processed
    => can't process some server rsp
      - unknown format (no such obj in dispatcher)
      - obj instance wasn't scheduled to wait on server rsp

  containers for combined msgs
    = equal type as other msgs
    Attributes
      execution: chain / pipe / parallel
        parallel = rsp can be returned in arbitrary sequence of other containers
        chain = similar to Haskell monads chaining
      results: discard / n-th / last / vector gather
        gather = return same container with all rsps
      flow: till 1st err / all
      failsafe: (all|any) err = ok / (any|all) err = err
    Consistency
      single op can req mult cmds to succeed
      atomically apply all of them to *dom* BUT: how ??
      revert incomplete operation
        E.G. no sense to chg curr path to parent's, if you can't load/recv its file list
      containers must incapsulate this atomic behaviour


%% Channel
  queue multiple msgs
    save each msg to queue and continue wait on socket
    mark msg by emitter for response (add back-ref to client)
      ~ directly use ref to explicitly call client code
      ~ use 'id' to resolve it into client
        BETTER :: allows to use write queue
        http://stackoverflow.com/questions/10605083/python-asyncore-keep-track-of-clients
  special 'cancel <op>' msg to reset queue
    what receiving data format to be expected to 'cancel' at any time ?
  reply to same client
    embed returning 'id'
  broadcast *dom* state change
    do it until *ui* and only there make decision to update *cursor*
      = make updating _on demand_ only
  msg => cmd => class
    search handler by type/class
      = Haskell way
      = C++ polymorphisms
    easier to process/split cmds queue/pool
  cmd authentication (check access/ops permissions), logging
    NEED formal dispatcher between cmd and handler
  cmd => event


%% Serialization
  [_] TRY: json/gzip
  REF
    https://en.wikipedia.org/wiki/Comparison_of_data_serialization_formats
  Blog
    https://www.sitepoint.com/choosing-right-serialization-format/
    http://stackoverflow.com/questions/144435/whats-the-best-way-to-serialize-data-in-a-language-independent-binary-format
    http://maxondev.com/serialization-performance-comparison-c-net-formats-frameworks-xmldatacontractserializer-xmlserializer-binaryformatter-json-newtonsoft-servicestack-text/
  E.G.
    http://msgpack.org/
