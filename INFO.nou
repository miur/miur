%%%%% IDEA
*Ranger done right*
Refactoring and evolution
Microkernel relay in fm world
++ Accessibility
  add key hooks to TTS dirs content for blind people

TODO
  [_] DEV: intelligent monitoring of user activity statistics
    * user typical behavior patterns -- headless wandering up-down-up-down, looking into random files, etc..
    * separate statistics <frame> per each dynamic workflow switch
    CASE: user goes to categorize 1000+ files for 4 hours
      -- then on retro he looks into statistics and thinks about mapping decisions on task volume
    CASE: unpacking-deleting many archives with bug logs, finding, reading logs, and grepping
      -- then optimizing keymaps or even creating separate workflow *mode* for this regular work task
      e.g. categorizing --> use 'c' to 'cut' file and 'i' to 'insert'
      e.g. regularization --> use 'c' and 'i' to rename files
    !! BET: apply such usage statistics on whole user system stack :: kernel + wm + web + fm + editor
      <= because workflow is straight-through all these systems
      + monitoring system load/events/traces can be also useful by itself (system optimizing)
        or as auxiliary data (user ifc usage latency due to network speed)
  [_] IDEA: fm cfg -- is also filesystem-like virtual structure (registry)
  [_] TRY: tightly integrate with Linux system-wide ecosystem
    e.g. kernel, systemd, dbus, coreutils, wm, editor, etc.
    = don't create your own services, daemons, mounts and sockets -- you have systemd
    = don't create your own communication bus -- you have dbus
    = don't create media framework -- you have gstreamer
    = don't manage windows -- you have wm
    <= after all each *workflow* permeats everything on all levels through whole system
      * e.g. modal keybindings are <global> and full immediate keyset is composed from all programs
  [_] make keybindings (key->func) into simple plugin, which can be replaced, augmented or overlayed
  [_] SEE graph database
    => maybe idea how to store *dom* ?
    ? similar to btrfs decomposition
  [_] ALT: search file manager in Lisp
    NOTE: lisp
      + flexible language/domain boundary and REPL => useful for extending
      - large deps, can't be easily ported to C for embedded pltf
      ? How to postpone this arch decision to allow to introduce Lisp glue power in later stages ?
    https://github.com/stacksmith/cl-fm
    +? https://github.com/vozhyk-/minifileman
    https://github.com/kostafey/flex-commander
    https://github.com/lup777/emcfmgr
    https://github.com/escherdragon/sunrise-commander
  [_] move ideas from 'term/ranger'
  [_] move ideas from 'nou.vim'
  [_] IDEA:SEE Emacspeak's table browsing functionality (online docs)
    = richest collection of end-user affordances for working with two-dimensional data.
    + MAYBE useful for my graph representations
  [_] THINK audio notions for working with text
  [_] Combine skeleton from ready-to-use libs
    * borrow ideas from neovim
    * write glue in whatever hell there is
    ! postpone more decisions for better arch, more drop-in replacements !
    http://libuv.org/
      https://github.com/libuv/libuv
    https://github.com/ClusterLabs/libqb
    https://habrahabr.ru/company/centosadmin/blog/323556/
  [_] NEED: fault-tolerance for server part to continue to work
  [_] NEED: ifc sep to impl audio ifc !

Fork
  ? is there need for compatibility with python2 ?
  ? MAYBE use C++ or haskell instead of python ?
  I can use 'ranger' as prototype and integrate my ideas there first
  \ and then use its architecture and found flaws to develop C++/haskell variant
    FIND concrete code parts to rewrite which I will touch
      = attach refs to the issue
      = point concrete actions I will take in rewriting
    Gather more usecases which demand such refactoring
  ALSO:(reverse-prototype) I can develop simple skeleton with my splitted
  \ architecture to test my vision before refactoring ranger codebase in its direction
    * it also allows to test ideas directly in my small framework
    * this prototype will be the first step for haskell port

Deps
  http://suckless.org/rocks
  https://gist.github.com/XVilka/8346728
  http://wiki.musl-libc.org/wiki/Alternative_libraries


Goal
  ship/activate only necessary subset of modules for each OS/distribution
    => like another TUI on Windows, etc
  complete abstraction ui layer
    to be able to test ifc with unit/mock
  providing universal DOM
    show graphs to user
    allow to apply commands


Usability
  tiling WM -- many instances in many terminals
  low usability of task manager
  low usability of preview window


Performance
  slow access / dir listing
    kernel/firmware sources
    always slow flattening
    when I need load all recursive -- for 'ag' search results


splitted modules
  don't load all python code at once
  future extensibility


Problems with functionality
  vim great -- because it's somewhat more universal interface than ranger
  slow fs -- like network fs with slow ping : sshfs, curlfs, nfs, imapfs
    > disable metainfo/preview only for choosen dirs
  many hardcoded defaults/routines which are impossible to extend/disable
    ~ like using file.basename in directory.py/refilter()
    ~ or always loading file metainfo on directory read
  open vim inside ranger inside vim -- need to return action
