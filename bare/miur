#!/usr/bin/env python
#
# SPDX-FileCopyrightText: 2020 Dmytro Kolomoiets <amerlyq@gmail.com> and contributors.
#
# SPDX-License-Identifier: GPL-3.0-only
#
# SUMMARY: crude fm impl
#
# SEIZE:TUT: http://urwid.org/tutorial/index.html
#
# NICE:READ: http://hintjens.com/blog:84
#

import logging
import os, os.path as fs
import sys
import threading
import time

import pickle
import urwid

import zmq
from zmq import devices
from zmq.log.handlers import PUBHandler


__appname__ = "miur"


def ui_client(src_uri, dst_uri):
    set_current_thread_name()
    ctx = zmq.Context.instance()

    # NOTE:(cohesion): connect topology backward :: from dst to src
    pub = ctx.socket(zmq.PUSH)
    pub.connect(dst_uri)

    _log = zeromq_log(pub, logging.DEBUG)

    sub = ctx.socket(zmq.SUB)
    sub.connect(src_uri)
    sub.setsockopt_string(zmq.SUBSCRIBE, '*')  # custom broadcast
    sub.setsockopt_string(zmq.SUBSCRIBE, 'ui')

    try:
        ## BET: python-urwid
        # [Urwid] key capture in different views
        # http://lists.excess.org/pipermail/urwid/2011-July/001080.html
        body = urwid.Text("<Press ',' to exit>")
        view = urwid.Filler(body, 'top')

        def unhandled_input(key):
            if key in ('esc', ','):
                raise urwid.ExitMainLoop()
            pub.send_multipart([b'key', pickle.dumps(key)])
            _log.info("Press: " + key)

            # FIXME: change text only in subscriber
            body.set_text(repr(key))

        loop = urwid.MainLoop(view, unhandled_input=unhandled_input)
        loop.run()

    except KeyboardInterrupt:
        pass
    finally:
        _log.info("Fin: " + threading.current_thread().name)
        pub.send_multipart([b'*', pickle.dumps('quit')])
        pub.close()
        sub.close()
        # ERR:(exception): can call only once in main thread
        # zmq.Context.instance().term()


def zeromq_log(dst, lvl=None):
    ## Gather all logs
    # https://github.com/zeromq/pyzmq/blob/master/examples/logger/zmqlogger.py
    # https://pyzmq.readthedocs.io/en/latest/api/zmq.log.handlers.html
    # ++ https://stackoverflow.com/questions/40218325/use-of-pyzmqs-logging-handler-in-python
    # zlog = PUBHandler('inproc://log')
    # NOTE: use the same dst_uri sink as other modules
    handler = PUBHandler(dst)
    handler.root_topic = 'log'
    return redirect_log(handler, lvl)


def filename_log(lvl=None):
    d_build = fs.join(fs.dirname(fs.dirname(__file__)), "_build")
    f_log = fs.join(d_build, __appname__ + ".log")
    os.makedirs(d_build, exist_ok=True)
    handler = logging.FileHandler(f_log)
    return redirect_log(handler, lvl)


def redirect_log(handler, lvl=None):
    tid = threading.get_native_id()  # OR: str(os.getpid())
    mod = __name__.partition('.')[2].partition('.')[0]
    mod = (mod if mod else 'root') + '-' + str(tid)
    fmt = "%(asctime)s %(name)8s %(levelname:<8s) [%(module)s:%(lineno)d]: %(message)s"

    # TODO: also print pid/tid inside log msg to distinguish threads
    # SEE: https://stackoverflow.com/questions/38323810/does-pythons-logging-config-dictconfig-apply-the-loggers-configuration-setti
    logging.basicConfig(
        level=(lvl if lvl is not None else logging.DEBUG),
        handlers=(handler,),
        datefmt="%H:%M:%S",
        format=fmt
    )
    return logging.getLogger(mod)


def logger_sink(src_uri, dst_uri, log_uri):
    set_current_thread_name()
    ctx = zmq.Context.instance()

    sub = ctx.socket(zmq.XSUB)
    sub.connect(log_uri)
    sub.setsockopt_string(zmq.SUBSCRIBE, '')

    mon = ctx.socket(zmq.SUB)
    mon.connect(src_uri)
    mon.setsockopt_string(zmq.SUBSCRIBE, '')

    _log = filename_log()
    _log.info('-' * 40)

    try:
        while True:
            frames = sub.recv_multipart()
            topic = frames[0].decode('utf-8')
            if topic.startswith('log'):
                lvl = getattr(logging, topic.partition('.')[2])
                msg = frames[1].decode('utf-8')
                if msg.endswith('\n'):
                    msg = msg[:-1]
            else:
                lvl = logging.DEBUG
                msg = pickle.loads(frames[1])

            _log.log(lvl, '[' + topic + '] ' + str(msg))

    except (zmq.ContextTerminated, KeyboardInterrupt):
        pass
    finally:
        # _log.info("Fin: " + threading.current_thread().name)
        sub.close()


def set_current_thread_name(nm=None):
    if nm is None:
        import inspect
        nm = inspect.currentframe().f_back.f_code.co_name
    nm = __appname__ + "/" + nm
    threading.current_thread().name = nm

    # HACK:BAD:(docs): overwrites "sys.argv" to change process name
    # BET: use explicit shebang "#!/usr/bin/python" and substitute path in post-install hook (for virtualenv)
    #   OR by maintainer when building package for concrete distribution
    try:
        import prctl
        prctl.set_name(nm)
    except:
        pass



# BET? zeromq/malamute IMPL broker patterns
#   https://github.com/zeromq/malamute
# OR: zeromq/majordomo IMPL clients <-> services
#   https://github.com/zeromq/majordomo
# ALSO: zeromq/filemq IMPL file transfering on request
#   https://github.com/zeromq/filemq
# NOTE: queue .vs. forwarder
#   https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/pyzmq/devices/queue.html
#   https://learning-0mq-with-pyzmq.readthedocs.io/en/latest/pyzmq/devices/forwarder.html
#   ::: we don't need MonitoredForwarder -- simply connect monitor as one of subscribers
#   [_] TODO: hub must inject broadcast msg "hub {pub|sub} [dis]connected <module>"
def broker_hub(src_uri, dst_uri):
    # CHG: use broker only as discovery service
    #   http://wiki.zeromq.org/whitepapers:brokerless#toc3
    # INFO: PULL+XPUB :: https://github.com/zeromq/libzmq/issues/2267
    # ENH: use clone{srv,cli}5.py :: PUB+ROUTER+PULL server
    #   http://zguide.zeromq.org/py:all#Reliable-Pub-Sub-Clone-Pattern
    # TODO: cap (capture) socket to redirect everything to external logger module
    #   BET: connect logger as any other module but with SUB('')
    # TODO: ctl (conntrol) socket to control flow from logger/etc.
    hub = devices.ThreadDevice(zmq.FORWARDER, zmq.PULL, zmq.XPUB)
    hub.bind_in(dst_uri)
    # FIXED: +++ https://stackoverflow.com/questions/30864145/zmq-no-subscription-message-on-xpub-socket-for-multiple-subscribers-last-value/30975378
    # hub.setsockopt_out(zmq.XPUB_VERBOSE, True)
    hub.bind_out(src_uri)
    # CHECK: drain all messages from queue on reconnect before loop
    #     e.g. msgs with timestamp less then ./hub starttime
    #   => otherwise on ./hub restart it will get and replay all messages,
    #     already obsolete at that moment
    hub.start()


def main(argv):
    set_current_thread_name()

    src_uri = "inproc://broker"     # RENAME: events
    dst_uri = "inproc://feedback"   # RENAME: posts
    log_uri = "inproc://log"
    trace_uri = "inproc://trace"
    client_uri = (src_uri, dst_uri, log_uri)

    broker_hub(dst_uri, src_uri)

    # threading.excepthook = handle_exception  # NEED: python>=3.8
    threading.Thread(target=logger_sink, args=client_uri).start()

    # BAD: "urwid" must be the main thread, because raw_screen.start() registers UNIX signals
    ui_client(*client_uri)

    # WARN: can call only once in main thread
    # NEED: call before joining threads to interrupt zmq.proxy
    zmq.Context.instance().term()

    for t in threading.enumerate():
        if t is not threading.main_thread():
            t.join()


if __name__ == "__main__":
    main(sys.argv)
