#!/usr/bin/env python
#
# SPDX-FileCopyrightText: 2020 Dmytro Kolomoiets <amerlyq@gmail.com> and contributors.
#
# SPDX-License-Identifier: GPL-3.0-only
#
# SUMMARY: crude fm impl
#

import logging
import os, os.path as fs
import sys
import threading
import time

# import blessed
import inspect
import prctl
import urwid
import zmq


__appname__ = "miur"
_log = logging.getLogger(__name__.partition('.')[2].partition('.')[0])


def ui_client(src_uri, dst_uri):
    set_current_thread_name()
    ctx = zmq.Context.instance()

    src_sock = ctx.socket(zmq.SUB)
    src_sock.setsockopt_string(zmq.SUBSCRIBE, '')
    src_sock.connect(src_uri)

    dst_sock = ctx.socket(zmq.PUB)
    dst_sock.connect(dst_uri)

    try:
        ## BET: python-urwid
        body = urwid.Text("Text")
        prompt = urwid.Edit("Prompt: ")
        view = urwid.Frame(
            header=prompt,
            body=urwid.Filler(body, valign='bottom'),
            focus_part='header')

        def exit_when(k):
            if k in ('q', 'Q', 'enter'):
                raise urwid.ExitMainLoop()

        loop = urwid.MainLoop(view, unhandled_input=exit_when)
        loop.run()

        ## ALT: python-blessed
        # term = blessed.Terminal()
        # with term.cbreak():
        #     key = ''
        #     while key.lower() != 'q':
        #         key = term.inkey(timeout=5)
        #         if not key:
        #             _log.info("Timeout")
        #         elif key.is_sequence:
        #             print("got sequence: {0}.".format((str(key), key.name, key.code)))
        #         elif key:
        #             _log.debug(f'got {key}')
        #             dst_sock.send_pyobj(key)
    finally:
        dst_sock.send_pyobj('q')
        dst_sock.close()
        src_sock.close()
        # ERR:(exception): can call only once in main thread
        # zmq.Context.instance().term()
    _log.info("End: " + threading.current_thread().name)


# RENAME? communication_hub
def central_hub(src_uri, dst_uri):
    set_current_thread_name()
    ctx = zmq.Context.instance()

    src_sock = ctx.socket(zmq.SUB)
    src_sock.setsockopt_string(zmq.SUBSCRIBE, '')
    src_sock.bind(src_uri)

    dst_sock = ctx.socket(zmq.PUB)
    dst_sock.bind(dst_uri)

    try:
        # FIXME: drain all messages from queue on reconnect before loop
        #     e.g. msgs with timestamp less then ./hub starttime
        #   => otherwise on ./hub restart it will get and replay all messages,
        #     already obsolete at that moment
        cmd = None
        while not isinstance(cmd, str) or cmd.lower() != 'q':
            cmd = src_sock.recv_pyobj()
            _log.info(cmd)
            dst_sock.send_pyobj(cmd)
        _log.info("End: " + threading.current_thread().name)
    except KeyboardInterrupt:
        dst_sock.send_pyobj('q')
    finally:
        dst_sock.close()
        src_sock.close()
        # ERR:(exception): can call only once in main thread
        # zmq.Context.instance().term()


def set_current_thread_name(nm=None):
    if nm is None:
        nm = inspect.currentframe().f_back.f_code.co_name
    nm = __appname__ + "/" + nm
    threading.current_thread().name = nm
    prctl.set_name(nm)


def handle_exception(a):
    if issubclass(a.exc_type, KeyboardInterrupt):
        threading.__excepthook__(a.exc_type, a.exc_value, a.exc_traceback)
        return
    # _log.addHandler(logging.StreamHandler(stream=sys.stderr))
    _log.critical("Uncaught exception", exc_info=(a.exc_type, a.exc_value, a.exc_traceback))


def init_logging(level=logging.INFO):
    d_build = fs.join(fs.dirname(fs.dirname(__file__)), "_build")
    os.makedirs(d_build, exist_ok=True)
    logging.basicConfig(
        level=level,
        filename=fs.join(d_build, __appname__ + ".log"),
        datefmt="%H:%M:%S",
        format=("%(asctime)s %(name)8s %(levelname)s " +
                "[%(module)s:%(lineno)d]: %(message)s")
    )


def main(argv):
    init_logging(logging.DEBUG)
    _log.info('-' * 40)

    # HACK:BAD:(docs): overwrites "argv" to change process name
    # BET: use explicit shebang "#!/usr/bin/python" and substitute path in post-install hook (for virtualenv)
    #   OR by maintainer when building package for concrete distribution
    prctl.set_name(__appname__)
    set_current_thread_name()

    io_uri = "inproc://input"
    ev_uri = "inproc://events"

    # threading.excepthook = handle_exception  # NEED: python>=3.8
    threading.Thread(name="hub", target=central_hub, args=(io_uri, ev_uri)).start()

    # BAD: "urwid" must be the main thread, because raw_screen.start() registers UNIX signals
    ui_client(ev_uri, io_uri)

    for t in threading.enumerate():
        if t is not threading.main_thread():
            t.join()

    # WARN: can call only once in main thread
    zmq.Context.instance().term()


if __name__ == "__main__":
    main(sys.argv)
